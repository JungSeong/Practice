## 객체지향 프로그래밍의 특징
1. 추상화 : 어떤 부류에서 **불필요한 요소는 제외**하고 **공통된 특징을 추출**하는 기법<br>
EX) 엔진 <- 내연기관 엔진 , 전기 엔진<br><br>
2. 캡슐화 : 복잡한 내부 기능을 묶어 외부에서 접근할 수 없도록 **불필요한 정보를 감추는 것**<br>
EX) private, protected...등등의 접근 지정자를 사용한다.<br><br>
3. 상속성 : 부모 객체의 특성을 **이어 받는 것**<br>
EX) 내연기관 엔진은 엔진의 특성을 상속받는다.<br><br>
4. 다형성 : 상속받은 객체는 자신만의 특성을 반영하여 **서로 다르게 동작한다.**<br>
EX) 내연기관 엔진 : 연료 연소로 동력 생산, 전기 엔진 : 모터 구동으로 동력 생산

## 용어 정리
클래스 : 객체가 포함하는 **데이터와 함수를 정의**하는 문법적인 요소

클래스가 포함하는 데이터 == 멤버 변수
클래스가 포함하는 함수 == 멤버 함수 (메서드), 이때 특별한 함수, 생성자와 소멸자를 포함할 수 있다.

생성자 : 객체가 생성될 때 자동으로 호출되는 함수
소멸자 : 객체가 소멸할 때 자동으로 호출되는 함수

## 클래스 선언 방법
~~~
class engine {...};
~~~

1. 클래스를 데이터 형식처럼 사용
~~~
engine my_engine;
~~~
2. 클래스 형식으로 동적 메모리를 할당한 후 해제 
~~~
engine *my_engine_pointer = new engine();
delete my_engine_pointer;
~~~

## 접근 지정자
|접근 지정자|설명|
|---|---|
|private|클래스 내의 맴버 함수에서만 접근 가능|
|public|다른 클래스 어디서든 접근 가능|
|protected|클래스 내의 맴버 함수나 상속 관계의 클래스에서 접근 가능|

[EX]
~~~
#include <iostream>

using namespace std;

class bank
{
    private:
        int safe;

    public:
        bank();
        void use_counter(int in, int out);
};

// 생성자
bank::bank()
{
    safe = 1000;
    cout << "최초 금고 : " << safe << endl;
    cout << endl;
}

void bank::use_counter(int in, int out)
{
    safe += in;
    safe -= out;

    cout << "입금 : " << in << endl;
    cout << "출금 : " << out << endl;
    cout << "금고 : " << safe << endl;
    cout << endl;
}

int main()
{
    bank my_bank;

    my_bank.use_counter(0, 20);
    my_bank.use_counter(50, 0);
    my_bank.use_counter(100, 50);

    return 0;
}
~~~

## 상속성과 다형성
**자식 클래스는 부모 클래스를 대체할 수 있는 특성을 가진다.** -> 부모 클래스는 자식 클래스로 치환할 수 있어야 한다.

## 단일 상속과 다중 상속
단일 상속 : 클래스를 상속 받을 때 부모 클래스를 하나만 지정<br>
다중 상속 : 클래스를 여러개 상속 받음

~~~
// character 클래스를 상속 받음
class player : public character {
    public :
        player(){};
};
~~~

다중 상속 : 둘 이상의 다른 종류의 클래스를 상속 받음

~~~
class monster_a : public monster, character
{
    public :
        void attack_special(player target_player);
};
~~~

이때, 상속을 지정할 때 클래스 이름 앞에 접근 지정자를 생략하면 private로 상속받는다.<br>
public monster -> monster은 public으로 상속 받고, character은 private로 상속 받음

public으로 지정한 경우 : 
~~~
class Parent {
public:
    int a;  // public 멤버
protected:
    int b;  // protected 멤버
private:
    int c;  // private 멤버
};

class Child : public Parent {
    // a는 public, b는 protected, c는 여전히 접근 불가(private)
};
~~~

private로 지정한 경우 : 
~~~
class Child : private Parent {
    // a는 private, b는 private, c는 여전히 접근 불가(private)
};
~~~

## 오버라이딩
오버라이딩 : 함수의 이름, 매개변수 구성, 반환 형식... 등등은 유지하면서 부모 클래스에 정의된 함수를 자식 클래스에서 재정의 하는 것

monster::attack_special(A a) <- monster_a::attack_special(A a)로 자식 클래스에서 재정의

~~~
#include <iostream>
using namespace std;

--- (생략) ---

int main()
{
    player player1;

    monster_a forest_monster;
    monster_b tutorial_monster;
    monster_c boss_monster;

    // 오버라이딩 함수의 호출
    // 오버라이딩 된 함수의 attack_special의 내용이 출력된다.

    cout << "오버라이딩 된 함수 호출" << endl;
    forest_monster.attack_special(player1);
    tutorial_monster.attack_special(player1);
    boss_monster.attack_special(player1);

    // 오버라이딩 함수는 네임스페이스를 통해 부모 클래스의 정의를 사용할 수 있다.
    // 부모 클래스의 attack_special의 내용만 출력된다.

    cout << "부모 클래스의 함수 호출" << endl;
    forest_monster.monster::attack_special(player1);
    tutorial_monster.monster::attack_special(player1);
    boss_monster.monster::attack_special(player1);
}
~~~

만약 자식 클래스를 부모 클래스의 레퍼런스로 접근하면 부모 클래스에 정의된 함수가 호출된다.

~~~
#include <iostream>
using namespace std;

--- (생략) ---

int main()
{
    player player1;
    monster_a forest_monster;

    monster &mon = forest_monster; // monster 형의 forest_monster 변수의 또 다른 이름 = mon
    monster_a &mon_a = forest_monster; // monster_a 형의 forest_monster 변수의 또 다른 이름 = mon_a

    // 부모 클래스의 레퍼런스로 공격
    mon.attack_special(player1);

    // 자식 클래스의 레퍼런스로 공격
    mon_a.attack_special(player1);
}
~~~

가상 함수(virtual)의 사용 : 부모 클래스를 참조 하더라도 객체에서 가장 마지막에 오버라이딩된 함수를 호출한다.

## 생성자와 소멸자
생성자 : 객체가 생성된 직후에 자동으로 호출되는 함수, 속성을 초기화 하는 등의 작업을 수행한다.

~~~
#include <iostream>
using namespace std;

class character{
    public:
        character(){ //character() == 생성자
            cout << "character 클래스 생성자" << endl;
        };
};

int main()
{
    character player;
    return 0;
}
~~~

생성자 호출 순서 : 부모의 생성자가 먼저 호출되고 나서 자식의 생성자가 호출된다.

값을 전달받는 생성자 : 매개변수로 전달받은 값으로 멤버 변수를 초기화한다.

~~~
#include <iostream>
#include <random>
using namespace std;

--- (생략) ---

//몬스터 A는 기본 Monster 클래스로부터 상속
class monster_a : public monster, character {
public:
// 기본 생성자
  monster_a() {
    cout << "monster_a 클래스 생성자" << endl;
  };

// 매개 변수가 있는 생성자
  monster_a(int x, int y, string str) : location{ x, y }, name(str) {
    cout << "monster_a 클래스 생성자 (매개변수 추가)" << endl;
  };

  void show_location() {
    cout << "위치(" << location[0] << " , " << location[1] << ")" << endl;
  };

  void show_name() {
    cout << "이름 : " << name << endl;
  };

private:
  int location[2];
  string name;
};

int main() {
  monster_a forest_monster;
  forest_monster.show_location();
  monster_a wood_monster(10, 25, "creaking");
  wood_monster.show_location();
  wood_monster.show_name();

  return 0;
}
~~~

값을 전달하는 생성자를 사용하면 기본 생성자는 실행되지 않는다.